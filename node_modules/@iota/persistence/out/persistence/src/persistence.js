"use strict";
exports.__esModule = true;
var async_buffer_1 = require("@iota/async-buffer");
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var Signing = require("@iota/signing");
var Promise = require("bluebird");
var events_1 = require("events");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
exports.PersistenceBatchTypes = types_1.PersistenceBatchTypes;
var KEY_INDEX_START = 0;
var KEY_INDEX_PREFIX = 'key_index';
function createPersistence(adapter) {
    var initialized;
    var source = adapter.createReadStream();
    var indexBuffer = async_buffer_1.asyncBuffer();
    var ready = function () {
        if (initialized === undefined) {
            initialized = new Promise(function (resolve, reject) {
                source.on('end', resolve);
                source.on('error', reject);
            }).then(function () {
                return adapter
                    .get(KEY_INDEX_PREFIX)
                    .then(indexBuffer.write)["catch"](function (error) {
                    if (error.notFound) {
                        // Intialize index field in store.
                        var index_1 = converter_1.valueToTrits(KEY_INDEX_START);
                        return adapter.put(KEY_INDEX_PREFIX, index_1).then(function () {
                            indexBuffer.write(index_1);
                        });
                    }
                    throw error;
                });
            });
        }
        return initialized;
    };
    function persistenceMixin() {
        var _this = this;
        return Object.assign(this, {
            ready: ready,
            increment: function () {
                return ready()
                    .then(function () { return indexBuffer.read(); })
                    .then(function (index) {
                    if (converter_1.tritsToValue(index) < KEY_INDEX_START || !Number.isSafeInteger(converter_1.tritsToValue(index))) {
                        throw new Error(errors.ILLEGAL_KEY_INDEX);
                    }
                    return index;
                })
                    .then(function (index) { return converter_1.valueToTrits(converter_1.tritsToValue(index) + 1); })
                    .then(function (index) {
                    return adapter
                        .put(KEY_INDEX_PREFIX, index)
                        .then(function () { return indexBuffer.write(index); })
                        .then(function () { return index; })["catch"](function (error) {
                        // On error, restore the buffer value and rethrow.
                        indexBuffer.write(index);
                        throw error;
                    });
                });
            },
            get: function (key) { return ready().then(function () { return adapter.get(key); }); },
            put: function (key, value) {
                return ready()
                    .then(function () { return adapter.put(key, value); })
                    .tap(function () {
                    return _this.emit('data', {
                        key: key,
                        value: value
                    });
                });
            },
            del: function (key) { return ready().then(function () { return adapter.del(key); }); },
            batch: function (commands) {
                return ready()
                    .then(function () { return adapter.batch(commands); })
                    .tap(function () {
                    return commands.filter(function (command) {
                        if (command.type === types_1.PersistenceBatchTypes.put) {
                            _this.emit('data', {
                                key: command.key,
                                value: command.value
                            });
                        }
                    });
                });
            },
            open: adapter.open,
            close: adapter.close
        }, events_1.EventEmitter.prototype);
    }
    var persistence = persistenceMixin.apply({});
    ready().then(function () { return persistence.emit('ready'); });
    source.on('data', function (data) { return persistence.emit('data', data); });
    return persistence;
}
exports.createPersistence = createPersistence;
exports.generatePersistenceID = function (seed) {
    if (!guards_1.isTrits(seed) || seed.length !== kerl_1["default"].HASH_LENGTH) {
        throw new Error(errors.ILLEGAL_SEED_LENGTH);
    }
    var address = Signing.address, digests = Signing.digests, key = Signing.key, subseed = Signing.subseed;
    var sponge = new kerl_1["default"]();
    var index = KEY_INDEX_START;
    var security = 2;
    var id = new Int8Array(kerl_1["default"].HASH_LENGTH);
    sponge.absorb(address(digests(key(subseed(seed, index), security))), 0, kerl_1["default"].HASH_LENGTH);
    sponge.squeeze(id, 0, kerl_1["default"].HASH_LENGTH);
    return converter_1.tritsToTrytes(id);
};
//# sourceMappingURL=persistence.js.map