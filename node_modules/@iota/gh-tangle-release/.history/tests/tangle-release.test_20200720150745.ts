import * as core from "@actions/core";
import { IConfig } from "../src/models/IConfig";
import { tangleRelease } from "../src/tangle-release";

let inputs = {};

describe("Tangle Release", () => {
    let setFailedMock;
    beforeEach(() => {
        process.env.GITHUB_TOKEN = "TOKEN";
        jest.spyOn(console, "log").mockImplementation();
        setFailedMock = jest.spyOn(core, "setFailed");
        inputs = {};
        jest.spyOn(core, "getInput").mockImplementation((name, options) => {
            if (options?.required && !inputs[name]) {
                throw new Error(`Input required and not supplied: ${name}`);
            }

            return inputs[name] as string;
        });
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    test("No GITHUB_TOKEN", async () => {
        const config: IConfig = {};
        await tangleRelease(config);
        expect(setFailedMock).toHaveBeenCalledWith("You must provide the GitHub token setting");
    });

    test("No seed", async () => {
        const config: IConfig = {
            githubToken: "aaa"
        };
        await tangleRelease(config);
        expect(setFailedMock).toHaveBeenCalledWith("You must provide the seed setting");
    });

    test("No tag_name", async () => {
        const config: IConfig = {
            githubToken: "aaa",
            seed: "A".repeat(81),
            repository: "repo1/app1"
        };
        await tangleRelease(config);
        expect(setFailedMock).toHaveBeenCalledWith("Input required and not supplied: tag_name");
    });

    test("unmocked octokit bad credentials", async () => {
        const config: IConfig = {
            githubToken: "aaa",
            seed: "A".repeat(81),
            repository: "repo1/app1",
            releaseTagName: "mytag"
        };
        await tangleRelease(config);
        expect(setFailedMock).toHaveBeenCalledWith("Bad credentials");
    });
});
