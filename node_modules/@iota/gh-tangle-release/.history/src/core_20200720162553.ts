/* eslint-disable camelcase */
import { getOctokit } from "@actions/github";
import { downloadAndHash } from "./crypto";
import { attachToTangle } from "./iota";
import { IConfig } from "./models/IConfig";
import { IPayload } from "./models/IPayload";

/**
 * Santirize the input parameters.
 * @param config The config for the release.
 * @returns The config as non partial.
 */
export function sanitizeInput(config: Partial<IConfig>): IConfig {
    if (!config.githubToken) {
        throw new Error("You must provide the GitHub token setting");
    }
    if (!config.owner) {
        throw new Error("You must provide the owner setting");
    }
    if (!config.repository) {
        throw new Error("You must provide the repository setting");
    }
    if (!config.releaseTagName) {
        throw new Error("You must provide the releaseTagName setting");
    }
    if (!config.seed) {
        throw new Error("You must provide the seed setting");
    }

    config.tag = config.tag ?? "GITHUB9RELEASE";
    config.tangleExplorer = config.tangleExplorer ?? "https://utils.iota.org/transaction/:hash";
    config.node = config.node ?? "https://nodes.iota.cafe:443";

    let addressIndex: number;
    let depth: number;
    let mwm: number;

    if (typeof config.addressIndex === "string") {
        addressIndex = Number.parseInt(config.addressIndex, 10);
    } else if (config.addressIndex === undefined) {
        addressIndex = 0;
    } else {
        addressIndex = config.addressIndex;
    }
    if (typeof config.depth === "string") {
        depth = Number.parseInt(config.depth, 10);
    } else if (config.depth === undefined) {
        depth = 3;
    } else {
        depth = config.depth;
    }
    if (typeof config.mwm === "string") {
        mwm = Number.parseInt(config.mwm, 10);
    } else if (config.mwm === undefined) {
        mwm = 14;
    } else {
        mwm = config.mwm;
    }

    return {
        githubToken: config.githubToken,
        tangleExplorer: config.tangleExplorer,
        node: config.node,
        depth,
        mwm,
        addressIndex,
        seed: config.seed,
        tag: config.tag,
        owner: config.owner,
        repository: config.repository,
        releaseTagName: config.releaseTagName,
        comment: config.comment
    };
}

/**
 * Create a tangle payload for a GitHub release.
 * @param config The config for the release.
 * @returns The hash of the transaction and an explorer url.
 */
export async function tangleRelease(config: IConfig): Promise<{
    /**
     * The hash of the transaction created.
     */
    hash: string;
    /**
     * The url to view the hash.
     */
    url: string;
}> {
    sanitizeInput(config);

    const octokit = getOctokit(config.githubToken);

    const release = await octokit.repos.getReleaseByTag({
        owner: config.owner,
        repo: config.repository,
        tag: config.releaseTagName.replace("refs/tags/", "")
    });

    if (!release) {
        throw new Error("Unable to retrieve release");
    }

    console.log("Downloading tarball");
    const tarBallHash = await downloadAndHash(release.data.tarball_url);

    console.log("Downloading zipball");
    const zipBallHash = await downloadAndHash(release.data.zipball_url);

    console.log("Constructing payload");
    const payload: IPayload = {
        owner: config.owner ?? "",
        repo: config.repository ?? "",
        tag_name: release.data.tag_name,
        name: release.data.name,
        comment: config.comment,
        body: release.data.body,
        tarball_url: release.data.tarball_url,
        tarball_sig: tarBallHash,
        zipball_url: release.data.zipball_url,
        zipball_sig: zipBallHash,
        assets: undefined
    };

    console.log("Processing assets");
    if (release.data.assets && release.data.assets.length > 0) {
        payload.assets = [];
        for (let i = 0; i < release.data.assets.length; i++) {
            const assetHash = await downloadAndHash(release.data.assets[i].browser_download_url);
            payload.assets.push({
                name: release.data.assets[i].name,
                size: release.data.assets[i].size,
                url: release.data.assets[i].browser_download_url,
                sig: assetHash
            });
        }
    }

    console.log("Attaching to tangle");
    const txHash = await attachToTangle(
        node ?? "",
        depth,
        mwm,
        config.seed,
        addressIndex,
        tag,
        payload
    );

    const exploreUrl = tangleExplorer.replace(":hash", txHash);
    console.log(`You can view the transaction on the tangle at ${exploreUrl}`);

    return {
        hash: txHash,
        url: exploreUrl
    };
}
