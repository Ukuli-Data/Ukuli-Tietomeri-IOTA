/* eslint-disable camelcase */
import { setFailed, setOutput } from "@actions/core";
import { getOctokit } from "@actions/github";
import { downloadAndHash } from "./crypto";
import { attachToTangle } from "./iota";
import { IConfig } from "./models/IConfig";
import { IPayload } from "./models/IPayload";

/**
 * Create a tangle payload for a GitHub release.
 * @param config The config for the release.
 */
export async function tangleRelease(config: IConfig): Promise<{
    /**
     * The hash of the transaction created.
     */
    hash: string;
    /**
     * The url to view the hash.
     */
    url: string;
}> {
    try {
        if (!config.githubToken) {
            throw new Error("You must provide the GitHub token setting");
        }
        if (!config.owner) {
            throw new Error("You must provide the owner setting");
        }
        if (!config.repository) {
            throw new Error("You must provide the repository setting");
        }
        if (!config.releaseTagName) {
            throw new Error("You must provide the tag_name setting");
        }
        if (!config.seed) {
            throw new Error("You must provide the seed setting");
        }

        const tag = config.tag ?? "GITHUB9RELEASE";
        const tangleExplorer = config.tangleExplorer ?? "https://utils.iota.org/transaction/:hash";
        const node = config.node ?? "https://nodes.iota.cafe:443";

        let addressIndex = Number.parseInt(config.addressIndex ?? "", 10);
        let depth = Number.parseInt(config.depth ?? "", 10);
        let mwm = Number.parseInt(config.mwm ?? "", 10);

        if (Number.isNaN(addressIndex)) {
            addressIndex = 0;
        }

        if (Number.isNaN(mwm)) {
            mwm = 14;
        }

        if (Number.isNaN(depth)) {
            depth = 3;
        }

        const octokit = getOctokit(config.githubToken);

        const release = await octokit.repos.getReleaseByTag({
            owner: config.owner,
            repo: config.repository,
            tag: config.releaseTagName.replace("refs/tags/", "")
        });

        if (!release) {
            throw new Error("Unable to retrieve release");
        }

        console.log("Downloading tarball");
        const tarBallHash = await downloadAndHash(release.data.tarball_url);

        console.log("Downloading zipball");
        const zipBallHash = await downloadAndHash(release.data.zipball_url);

        console.log("Constructing payload");
        const payload: IPayload = {
            owner: config.owner,
            repo: config.repository,
            tag_name: release.data.tag_name,
            name: release.data.name,
            comment: config.comment,
            body: release.data.body,
            tarball_url: release.data.tarball_url,
            tarball_sig: tarBallHash,
            zipball_url: release.data.zipball_url,
            zipball_sig: zipBallHash,
            assets: undefined
        };

        console.log("Processing assets");
        if (release.data.assets && release.data.assets.length > 0) {
            payload.assets = [];
            // eslint-disable-next-line no-plusplus
            for (let i = 0; i < release.data.assets.length; i++) {
                // eslint-disable-next-line no-await-in-loop
                const assetHash = await downloadAndHash(release.data.assets[i].browser_download_url);
                payload.assets.push({
                    name: release.data.assets[i].name,
                    size: release.data.assets[i].size,
                    url: release.data.assets[i].browser_download_url,
                    sig: assetHash
                });
            }
        }

        console.log("Attaching to tangle");
        const txHash = await attachToTangle(node, depth, mwm, config.seed, addressIndex, tag, payload);
        const exploreUrl = tangleExplorer.replace(":hash", txHash);
        console.log(`You can view the transaction on the tangle at ${exploreUrl}`);

        return {
            hash: txHash,
            url: exploreUrl
        };
    } catch (error) {
        setFailed(error.message);
        console.log("Failed");
        console.log(error);
    }
}
