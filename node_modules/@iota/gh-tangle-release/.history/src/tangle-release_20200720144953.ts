/* eslint-disable camelcase */
import { getInput, setFailed, setOutput } from "@actions/core";
import { context, getOctokit } from "@actions/github";
import { downloadAndHash } from "./crypto";
import { attachToTangle } from "./iota";
import { IConfig } from "./models/IConfig";
import { IPayload } from "./models/IPayload";

/**
 * Create a tangle payload for a GitHub release.
 * @param userConfig The config for the release.
 */
export async function tangleRelease(userConfig: IConfig): Promise<void> {
    try {
        const defaultConfig: IConfig = {
            tag: "GITHUB9RELEASE",
            tangleExplorer: "https://utils.iota.org/transaction/:hash",
            node: "https://nodes.iota.cafe:443"
        };

        const config = { ...defaultConfig, ...userConfig };

        if (!config.githubToken) {
            throw new Error("You must provide the gitHub token setting");
        }

        const octokit = getOctokit(config.githubToken);

        let addressIndex = Number.parseInt(config.addressIndex, 10);
        let depth = Number.parseInt(config.depth, 10);
        let mwm = Number.parseInt(config.mwm, 10);

        if (!config.seed) {
            throw new Error("You must provide the seed setting");
        }

        if (Number.isNaN(addressIndex)) {
            addressIndex = 0;
        }

        if (Number.isNaN(mwm)) {
            mwm = 14;
        }

        if (Number.isNaN(depth)) {
            depth = 3;
        }

        const { owner, repo } = context.repo;

        const tagName = getInput("tag_name", { required: true });
        console.log("Tag Name Retrieved");

        const comment = getInput("comment", { required: false });
        console.log("Comment Retrieved");

        const release = await octokit.repos.getReleaseByTag({
            owner,
            repo,
            tag: tagName.replace("refs/tags/", "")
        });

        if (!release) {
            throw new Error("Unable to retrieve release");
        }

        console.log("Downloading tarball");
        const tarBallHash = await downloadAndHash(release.data.tarball_url);

        console.log("Downloading zipball");
        const zipBallHash = await downloadAndHash(release.data.zipball_url);

        console.log("Constructing payload");
        const payload: IPayload = {
            owner,
            repo,
            tag_name: release.data.tag_name,
            name: release.data.name,
            comment,
            body: release.data.body,
            tarball_url: release.data.tarball_url,
            tarball_sig: tarBallHash,
            zipball_url: release.data.zipball_url,
            zipball_sig: zipBallHash,
            assets: undefined
        };

        console.log("Processing assets");
        if (release.data.assets && release.data.assets.length > 0) {
            payload.assets = [];
            // eslint-disable-next-line no-plusplus
            for (let i = 0; i < release.data.assets.length; i++) {
                // eslint-disable-next-line no-await-in-loop
                const assetHash = await downloadAndHash(release.data.assets[i].browser_download_url);
                payload.assets.push({
                    name: release.data.assets[i].name,
                    size: release.data.assets[i].size,
                    url: release.data.assets[i].browser_download_url,
                    sig: assetHash
                });
            }
        }

        console.log("Attaching to tangle");
        const txHash = await attachToTangle(config.node, depth, mwm, config.seed, addressIndex, config.tag, payload);
        const exploreUrl = config.tangleExplorer.replace(":hash", txHash);
        console.log(`You can view the transaction on the tangle at ${exploreUrl}`);
        setOutput("tx_hash", txHash);
        setOutput("tx_explore_url", exploreUrl);
    } catch (error) {
        setFailed(error.message);
        console.log("Failed");
        console.log(error);
    }
}
