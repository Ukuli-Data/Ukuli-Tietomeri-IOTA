import * as Promise from 'bluebird';
import { Validator } from '../../guards';
import { Bundle, Callback, Provider, Transaction, Transfer } from '../../types';
import Address from './address';
export { Bundle, Callback, Provider, Transaction, Transfer };
export interface MultisigInput {
    readonly address: string;
    readonly balance: number;
    readonly securitySum: number;
}
export declare const multisigInputValidator: Validator<MultisigInput>;
export declare const sanitizeTransfers: (transfers: readonly Transfer[]) => readonly Transfer[];
export declare const createBundle: (input: MultisigInput, transfers: readonly Transfer[], remainderAddress?: string | undefined) => Int8Array;
/**
 * @class Multisig
 *
 * @memberof module:multisig
 */
export default class Multisig {
    address: typeof Address;
    private provider;
    constructor(provider: Provider);
    /**
     * Gets the key value of a seed
     *
     * @member getKey
     *
     * @memberof Multisig
     *
     * @param {string} seed
     * @param {number} index
     * @param {number} security Security level to be used for the private key / address. Can be 1, 2 or 3
     *
     * @return {Int8Array} digest trytes
     */
    getKey(seed: string, index: number, security: number): Int8Array;
    /**
     * Gets the digest value of a seed
     *
     * @member getDigest
     *
     * @memberof Multisig
     *
     * @param {string} seed
     * @param {number} index
     * @param {number} security Security level to be used for the private key / address. Can be 1, 2 or 3
     *
     * @return {string} digest trytes
     **/
    getDigest(seed: string, index: number, security: number): string;
    /**
     * Validates  a generated multisig address
     *
     * @member validateAddress
     *
     * @memberof Multisig
     *
     * @param {string} multisigAddress
     * @param {array} digests
     *
     * @return {boolean}
     */
    validateAddress(multisigAddress: string, digestsArr: ReadonlyArray<string>): boolean;
    /**
     * Prepares transfer by generating the bundle with the corresponding cosigner transactions
     * Does not contain signatures
     *
     * @member initiateTransfer
     *
     * @memberof Multisig
     *
     * @param {object} input the input addresses as well as the securitySum, and balance where:
     * - `address` is the input multisig address
     * - `securitySum` is the sum of security levels used by all co-signers
     * - `balance` is the expected balance, if you wish to override getBalances
     * @param {string} remainderAddress Has to be generated by the cosigners before initiating the transfer, can be null if fully spent
     * @param {object} transfers
     * @param {function} callback
     *
     * @return {Int8Array} Bundle trits
     */
    initiateTransfer(input: MultisigInput, transfers: ReadonlyArray<Transfer>, remainderAddress?: string, callback?: Callback<Bundle>): Promise<Bundle>;
    /**
     * Adds the cosigner signatures to the corresponding bundle transaction
     *
     * @member addSignature
     *
     * @memberof Multisig
     *
     * @param {Int8Array} bundle
     * @param {number} cosignerIndex
     * @param {string} inputAddress
     * @param {string} keyTrits
     * @param {function} callback
     *
     * @return {Int8Array} bundle with signature trits
     */
    addSignature(bundle: Int8Array, inputAddress: string, keyTrits: Int8Array, callback: Callback): void;
}
