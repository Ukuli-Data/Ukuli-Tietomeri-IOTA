"use strict";
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var types_1 = require("../../types");
/**
 * @class Address
 * @memberof module:multisig
 */
var Address = /** @class */ (function () {
    function Address(digests) {
        this.kerl = new kerl_1["default"]();
        this.kerl.initialize();
        if (digests) {
            this.absorb(digests);
        }
    }
    /**
     * Absorbs key digests
     *
     * @member absorb
     *
     * @memberof Address
     *
     * @param {string|array} digest digest trytes
     *
     * @return {object} address instance
     */
    Address.prototype.absorb = function (digests) {
        // Construct array
        var digestsArray = types_1.asArray(digests);
        // Add digests
        for (var i = 0; i < digestsArray.length; i++) {
            // Get trits of digest
            var digestTrits = converter_1.trits(digestsArray[i]);
            // Absorb digest
            this.kerl.absorb(digestTrits, 0, digestTrits.length);
        }
        return this;
    };
    /**
     * Finalizes and returns the multisig address in trytes
     *
     * @member finalize
     *
     * @memberof Address
     *
     * @param {string} digest digest trytes, optional
     *
     * @return {string} address trytes
     */
    Address.prototype.finalize = function (digest) {
        // Absorb last digest if provided
        if (digest) {
            this.absorb(digest);
        }
        // Squeeze the address trits
        var addressTrits = new Int8Array(kerl_1["default"].HASH_LENGTH);
        this.kerl.squeeze(addressTrits, 0, kerl_1["default"].HASH_LENGTH);
        // Convert trits into trytes and return the address
        return converter_1.trytes(addressTrits);
    };
    return Address;
}());
exports["default"] = Address;
//# sourceMappingURL=address.js.map