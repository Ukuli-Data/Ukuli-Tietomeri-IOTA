"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var bundle_1 = require("@iota/bundle");
var checksum_1 = require("@iota/checksum");
var converter_1 = require("@iota/converter");
var core_1 = require("@iota/core");
var kerl_1 = require("@iota/kerl");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var address_1 = require("./address");
exports.multisigInputValidator = function (multisigInput) { return [
    multisigInput,
    function (input) {
        return guards_1.isSecurityLevel(input.securitySum) &&
            guards_1.isHash(input.address) &&
            Number.isInteger(input.balance) &&
            input.balance > 0;
    },
    errors.INVALID_INPUT,
]; };
exports.sanitizeTransfers = function (transfers) {
    return transfers.map(function (transfer) { return (__assign({}, transfer, { message: transfer.message || '', tag: transfer.tag || '', address: checksum_1.removeChecksum(transfer.address) })); });
};
/* tslint:disable:variable-name */
exports.createBundle = function (input, transfers, remainderAddress) {
    // Create a new bundle
    var bundle = transfers.reduce(function (acc, transfer) {
        var message = converter_1.trytesToTrits(transfer.message || '');
        var signatureOrMessageTrits = new Int8Array((1 + Math.floor(message.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH)) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
        signatureOrMessageTrits.set(message, transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
        return bundle_1.addEntry(acc, {
            signatureOrMessage: signatureOrMessageTrits,
            address: converter_1.trytesToTrits(checksum_1.removeChecksum(transfer.address)),
            value: converter_1.valueToTrits(transfer.value),
            obsoleteTag: converter_1.trytesToTrits(transfer.tag || ''),
            issuanceTimestamp: converter_1.valueToTrits(Math.floor(Date.now() / 1000))
        });
    }, new Int8Array(0));
    var totalBalance = input.balance;
    var totalValue = transfers.reduce(function (acc, transfer) { return (acc += transfer.value); }, 0);
    var remainder = totalBalance - totalValue;
    if (remainder < 0) {
        throw new Error('Not enough balance.');
    }
    if (totalBalance > 0) {
        // Add input as bundle entry
        // Only a single entry, signatures will be added later
        bundle = bundle_1.addEntry(bundle, {
            signatureOrMessage: new Int8Array(input.securitySum * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH),
            address: converter_1.trytesToTrits(input.address),
            value: converter_1.valueToTrits(0 - totalBalance),
            issuanceTimestamp: converter_1.valueToTrits(Math.floor(Date.now() / 1000))
        });
    }
    // If there is a remainder value
    // Add extra output to send remaining funds to
    if (remainder > 0) {
        // Remainder bundle entry if necessary
        if (!remainderAddress) {
            throw new Error('No remainder address defined');
        }
        bundle = bundle_1.addEntry(bundle, {
            signatureOrMessage: new Int8Array(transaction_1.SIGNATURE_OR_MESSAGE_LENGTH),
            address: converter_1.trytesToTrits(remainderAddress),
            value: converter_1.valueToTrits(remainder),
            issuanceTimestamp: converter_1.valueToTrits(Math.floor(Date.now() / 1000))
        });
    }
    return bundle_1.finalizeBundle(bundle);
};
/**
 * @class Multisig
 *
 * @memberof module:multisig
 */
var Multisig = /** @class */ (function () {
    function Multisig(provider) {
        this.address = address_1["default"];
        this.provider = provider;
    }
    /**
     * Gets the key value of a seed
     *
     * @member getKey
     *
     * @memberof Multisig
     *
     * @param {string} seed
     * @param {number} index
     * @param {number} security Security level to be used for the private key / address. Can be 1, 2 or 3
     *
     * @return {Int8Array} digest trytes
     */
    Multisig.prototype.getKey = function (seed, index, security) {
        return signing_1.key(signing_1.subseed(converter_1.trytesToTrits(seed), index), security);
    };
    /**
     * Gets the digest value of a seed
     *
     * @member getDigest
     *
     * @memberof Multisig
     *
     * @param {string} seed
     * @param {number} index
     * @param {number} security Security level to be used for the private key / address. Can be 1, 2 or 3
     *
     * @return {string} digest trytes
     **/
    Multisig.prototype.getDigest = function (seed, index, security) {
        var keyTrits = signing_1.key(signing_1.subseed(converter_1.trytesToTrits(seed), index), security);
        return converter_1.tritsToTrytes(signing_1.digests(keyTrits));
    };
    /**
     * Validates  a generated multisig address
     *
     * @member validateAddress
     *
     * @memberof Multisig
     *
     * @param {string} multisigAddress
     * @param {array} digests
     *
     * @return {boolean}
     */
    Multisig.prototype.validateAddress = function (multisigAddress, digestsArr) {
        var kerl = new kerl_1["default"]();
        // initialize Kerl with the provided state
        kerl.initialize();
        // Absorb all key digests
        digestsArr.forEach(function (keyDigest) {
            var digestTrits = converter_1.trytesToTrits(keyDigest);
            kerl.absorb(converter_1.trytesToTrits(keyDigest), 0, digestTrits.length);
        });
        // Squeeze address trits
        var addressTrits = new Int8Array(kerl_1["default"].HASH_LENGTH);
        kerl.squeeze(addressTrits, 0, kerl_1["default"].HASH_LENGTH);
        // Convert trits into trytes and return the address
        return converter_1.tritsToTrytes(addressTrits) === multisigAddress;
    };
    /**
     * Prepares transfer by generating the bundle with the corresponding cosigner transactions
     * Does not contain signatures
     *
     * @member initiateTransfer
     *
     * @memberof Multisig
     *
     * @param {object} input the input addresses as well as the securitySum, and balance where:
     * - `address` is the input multisig address
     * - `securitySum` is the sum of security levels used by all co-signers
     * - `balance` is the expected balance, if you wish to override getBalances
     * @param {string} remainderAddress Has to be generated by the cosigners before initiating the transfer, can be null if fully spent
     * @param {object} transfers
     * @param {function} callback
     *
     * @return {Int8Array} Bundle trits
     */
    Multisig.prototype.initiateTransfer = function (input, transfers, remainderAddress, callback) {
        var _this = this;
        return Promise.resolve(guards_1.validate(exports.multisigInputValidator(input), guards_1.arrayValidator(guards_1.transferValidator)(transfers), !!remainderAddress && guards_1.remainderAddressValidator(remainderAddress)))
            .then(function () { return exports.sanitizeTransfers(transfers); })
            .then(function (sanitizedTransfers) {
            return input.balance
                ? exports.createBundle(input, sanitizedTransfers, remainderAddress)
                : core_1.createGetBalances(_this.provider)([input.address])
                    .then(function (res) { return (__assign({}, input, { balance: res.balances[0] })); })
                    .then(function (inputWithBalance) {
                    return exports.createBundle(inputWithBalance, sanitizedTransfers, remainderAddress);
                });
        })
            .asCallback(callback);
    };
    /**
     * Adds the cosigner signatures to the corresponding bundle transaction
     *
     * @member addSignature
     *
     * @memberof Multisig
     *
     * @param {Int8Array} bundle
     * @param {number} cosignerIndex
     * @param {string} inputAddress
     * @param {string} keyTrits
     * @param {function} callback
     *
     * @return {Int8Array} bundle with signature trits
     */
    Multisig.prototype.addSignature = function (bundle, inputAddress, keyTrits, callback) {
        var bundleHashTrits = transaction_1.bundle(bundle);
        var normalizedBundleHash = signing_1.normalizedBundle(bundleHashTrits);
        var signatureIndex = 0;
        for (var offset = 0; offset < bundle.length * transaction_1.TRANSACTION_LENGTH; offset + transaction_1.TRANSACTION_LENGTH) {
            if (converter_1.tritsToTrytes(transaction_1.address(bundle)) === inputAddress && guards_1.isNinesTrytes(transaction_1.signatureOrMessage(bundle))) {
                var signature = new Int8Array(keyTrits.length);
                for (var i = 0; i < keyTrits.length / signing_1.FRAGMENT_LENGTH; i++) {
                    signature.set(signing_1.signatureFragment(normalizedBundleHash.slice(i * signing_1.NORMALIZED_FRAGMENT_LENGTH, (i + 1) * signing_1.NORMALIZED_FRAGMENT_LENGTH), keyTrits.slice(i * signing_1.FRAGMENT_LENGTH, (i + 1) * signing_1.FRAGMENT_LENGTH)), i * signing_1.FRAGMENT_LENGTH);
                }
                var bundleTrits = bundle_1.addSignatureOrMessage(bundle, signature, signatureIndex);
                var bundleTrytes = [];
                for (var jOffset = 0; jOffset < bundleTrits.length; jOffset += transaction_1.TRANSACTION_LENGTH) {
                    bundleTrytes.push(converter_1.tritsToTrytes(bundleTrits.slice(jOffset, jOffset + transaction_1.TRANSACTION_LENGTH)));
                }
                return callback(null, bundleTrytes.slice());
            }
            signatureIndex += 1;
        }
        return callback(new Error('Could not find signature index for address: ' + inputAddress));
    };
    return Multisig;
}());
exports["default"] = Multisig;
/**
 *   Multisig address constructor
 */
Multisig.prototype.address = address_1["default"];
//# sourceMappingURL=multisig.js.map