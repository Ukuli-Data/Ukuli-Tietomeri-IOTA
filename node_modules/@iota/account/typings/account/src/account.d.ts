/// <reference types="node" />
import { AsyncBuffer } from '@iota/async-buffer';
import { AbstractCDA } from '@iota/cda';
import { API } from '@iota/core';
import { Persistence } from '@iota/persistence';
import * as Promise from 'bluebird';
import { EventEmitter } from 'events';
import { CreatePersistenceAdapter, Transaction, Trytes } from '../../types';
export interface AddressGenerationParams {
    readonly seed: Int8Array;
    readonly security: 1 | 2 | 3;
    readonly persistence: Persistence<string, Int8Array>;
    readonly timeSource: TimeSource;
    readonly network: Network;
    readonly now: () => number;
}
export interface TransactionIssuanceParams {
    readonly seed: Int8Array;
    readonly deposits: AsyncBuffer<Int8Array>;
    readonly persistence: Persistence<string, Int8Array>;
    readonly network: Network;
    readonly timeSource: TimeSource;
    readonly security: 1 | 2 | 3;
    readonly now: () => number;
}
export interface NetworkParams {
    readonly provider: string;
}
export interface TransactionAttachmentParams {
    readonly network: Network;
    readonly bundles: AsyncBuffer<Int8Array>;
    readonly persistence: Persistence<string, Int8Array>;
}
export interface TransactionAttachmentStartParams {
    readonly depth: number;
    readonly minWeightMagnitude: number;
    readonly delay?: number;
    readonly maxDepth?: number;
    readonly now?: () => number;
}
export interface HistoryParams {
    readonly persistence: Persistence<string, Int8Array>;
}
export interface AccountParams {
    readonly seed: Int8Array | string;
    readonly provider?: string;
    readonly persistencePath?: string;
    readonly persistenceAdapter?: CreatePersistenceAdapter<string, Int8Array>;
    readonly network?: any;
    readonly timeSource?: TimeSource;
    readonly depth?: number;
    readonly minWeightMagnitude?: number;
    readonly delay?: number;
    readonly pollingDelay?: number;
    readonly maxDepth?: number;
    readonly emitTransferEvents?: boolean;
}
export interface AddressGeneration<X, Y> {
    readonly [generate: string]: ((params: X) => Promise<Y>) | any;
}
export interface TransactionIssuance<Y, Z> {
    readonly [send: string]: (params: Y | any) => Promise<Z>;
}
export interface Network {
    readonly findTransactions: API['findTransactions'];
    readonly getBalances: API['getBalances'];
    readonly getBalance: (address: Trytes) => Promise<number>;
    readonly getConsistency: API['checkConsistency'];
    readonly getInclusionStates: API['getInclusionStates'];
    readonly getTrytes: API['getTrytes'];
    readonly sendTrytes: API['sendTrytes'];
    readonly setSettings: API['setSettings'];
    readonly storeAndBroadcast: API['storeAndBroadcast'];
    readonly getTransactionsToApprove: API['getTransactionsToApprove'];
    readonly attachToTangle: API['attachToTangle'];
    readonly getBundlesFromAddresses: API['getBundlesFromAddresses'];
    readonly wereAddressesSpentFrom: API['wereAddressesSpentFrom'];
    readonly isAddressUsed: (address: Trytes) => Promise<{
        isUsed: boolean;
        isSpent: boolean;
        transactions: ReadonlyArray<Trytes>;
    }>;
}
export interface TransactionAttachment {
    readonly startAttaching: (params: TransactionAttachmentStartParams) => void;
    readonly stopAttaching: () => void;
}
export interface Deposit extends AbstractCDA {
    readonly address: Trytes;
    readonly index: number;
    readonly security: 1 | 2 | 3;
    readonly balance: number;
}
export interface AccountState {
    readonly deposits: ReadonlyArray<Deposit>;
    readonly withdrawals: ReadonlyArray<ReadonlyArray<Trytes>>;
    readonly lastKeyIndex: number;
}
export interface Account<X, Y, Z> extends AddressGeneration<X, Y>, TransactionIssuance<Y, Z>, TransactionAttachment, EventEmitter {
    stop: () => Promise<void>;
    start: () => Promise<void>;
    getTotalBalance: () => Promise<number>;
    getAvailableBalance: () => Promise<number>;
    getDeposits: () => Promise<Deposit>;
    getWithdrawals: () => Promise<ReadonlyArray<Transaction>>;
    exportState: () => Promise<AccountState>;
    importState: (state: AccountState) => Promise<void>;
}
export declare type TimeSource = () => Promise<number>;
export declare type CreateNetwork = (params: NetworkParams) => Network;
export declare type CreateAddressGeneration<X, Y> = (params: AddressGenerationParams) => AddressGeneration<X, Y>;
export declare type CreateTransactionIssuance<Y, Z> = (params: TransactionIssuanceParams) => TransactionIssuance<Y, Z>;
export declare type CreateTransactionAttachment<Z> = (params: TransactionAttachmentParams) => TransactionAttachment;
export declare type CreateAccount<X, Y, Z> = (params: AccountParams) => Account<X, Y, Z>;
export declare type CreateAccountWithPreset<X, Y, Z> = (preset: AccountPreset<X, Y, Z>) => CreateAccount<X, Y, Z>;
export interface AccountPreset<X, Y, Z> {
    readonly persistencePath: string;
    readonly persistenceAdapter: CreatePersistenceAdapter<string, Int8Array>;
    readonly provider: string;
    readonly network: CreateNetwork;
    readonly security: 1 | 2 | 3;
    readonly addressGeneration: CreateAddressGeneration<X, Y>;
    readonly transactionIssuance: CreateTransactionIssuance<Y, Z>;
    readonly transactionAttachment: CreateTransactionAttachment<Z>;
    readonly timeSource: TimeSource;
    readonly depth: number;
    readonly minWeightMagnitude: number;
    readonly delay: number;
    readonly pollingDelay: number;
    readonly maxDepth: number;
    readonly test: {
        [t: string]: any;
    };
    readonly [k: string]: any;
}
export declare const SENT_TO_ADDRESS_PREFIX = "sent_to";
export declare function createAccountWithPreset<X, Y, Z>(preset: AccountPreset<X, Y, Z>): CreateAccount<X, Y, Z>;
export declare const createAccount: CreateAccount<import("@iota/cda").CDAParams, import("@iota/cda").CDA, readonly string[]>;
