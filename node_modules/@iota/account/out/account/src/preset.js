"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var cda_1 = require("@iota/cda");
var converter_1 = require("@iota/converter");
var core_1 = require("@iota/core");
var http_client_1 = require("@iota/http-client");
var persistence_1 = require("@iota/persistence");
var persistence_adapter_level_1 = require("@iota/persistence-adapter-level");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var transaction_converter_1 = require("@iota/transaction-converter");
var Promise = require("bluebird");
require("../../typed-array");
var account_1 = require("./account");
var Events;
(function (Events) {
    Events["selectInput"] = "selectedInput";
    Events["prepareTransfer"] = "preparedTransfer";
    Events["getTransactionsToApprove"] = "getTransactionsToApprove";
    Events["attachToTangle"] = "attachToTangle";
    Events["broadcast"] = "broadcast";
    Events["error"] = "error";
})(Events = exports.Events || (exports.Events = {}));
function networkAdapter(_a) {
    var provider = _a.provider;
    var httpClient = http_client_1.createHttpClient({ provider: provider });
    var getBalances = core_1.createGetBalances(httpClient);
    var getTrytes = core_1.createGetTrytes(httpClient);
    var getInclusionStates = core_1.createGetInclusionStates(httpClient);
    return {
        getTrytes: function (hashes) { return (hashes.length > 0 ? getTrytes(hashes) : Promise.resolve([])); },
        getBalance: function (address) { return getBalances([address]).then(function (_a) {
            var balances = _a.balances;
            return balances[0];
        }); },
        getBalances: getBalances,
        getConsistency: core_1.createCheckConsistency(httpClient),
        getInclusionStates: function (hashes) { return (hashes.length > 0 ? getInclusionStates(hashes) : Promise.resolve([])); },
        getBundlesFromAddresses: core_1.createGetBundlesFromAddresses(httpClient, 'lib'),
        findTransactions: core_1.createFindTransactions(httpClient),
        sendTrytes: core_1.createSendTrytes(httpClient),
        setSettings: httpClient.setSettings,
        getTransactionsToApprove: core_1.createGetTransactionsToApprove(httpClient),
        attachToTangle: core_1.createAttachToTangle(httpClient),
        storeAndBroadcast: core_1.createStoreAndBroadcast(httpClient),
        wereAddressesSpentFrom: core_1.createWereAddressesSpentFrom(httpClient, 'lib'),
        isAddressUsed: core_1.createIsAddressUsed(httpClient)
    };
}
exports.networkAdapter = networkAdapter;
function addressGeneration(addressGenerationParams) {
    var seed = addressGenerationParams.seed, persistence = addressGenerationParams.persistence, timeSource = addressGenerationParams.timeSource, network = addressGenerationParams.network, now = addressGenerationParams.now;
    var prepareTransfers = core_1.createPrepareTransfers(undefined, now);
    var emitter = this; // tslint:disable-line
    function generateCDA(cdaParams) {
        if (!cdaParams) {
            throw new Error('Provide an object with conditions for the CDA: { timeoutAt, [multiUse], [exeptectedAmount], [security=2] }');
        }
        var timeoutAt = cdaParams.timeoutAt, expectedAmount = cdaParams.expectedAmount, multiUse = cdaParams.multiUse;
        return Promise["try"](function () { return timeSource().then(function (currentTime) { return cda_1.verifyCDAParams(currentTime, cdaParams); }); })
            .then(persistence.increment)
            .then(function (index) {
            var security = cdaParams.security || addressGenerationParams.security;
            var address = signing_1.address(signing_1.digests(signing_1.key(signing_1.subseed(seed, converter_1.tritsToValue(index)), security)));
            var addressTrytes = converter_1.tritsToTrytes(address);
            return network.isAddressUsed(addressTrytes).then(function (_a) {
                var isUsed = _a.isUsed, isSpent = _a.isSpent, transactions = _a.transactions;
                if (isUsed) {
                    return persistence
                        .put(['0', addressTrytes].join(':'), isSpent
                        ? new Int8Array(1)
                        : cda_1.serializeCDAInput({
                            address: address,
                            index: index,
                            security: security,
                            timeoutAt: 0
                        }))
                        .then(function () {
                        return emitter.emit('error', new Error('Skipping used address.'), {
                            address: addressTrytes,
                            isSpent: isSpent,
                            transactions: transactions
                        });
                    })
                        .then(function () { return generateCDA(cdaParams); });
                }
                var serializedCDA = cda_1.serializeCDAInput({
                    address: address,
                    index: index,
                    security: security,
                    timeoutAt: timeoutAt,
                    multiUse: multiUse,
                    expectedAmount: expectedAmount
                });
                return persistence
                    .put(['0', addressTrytes].join(':'), serializedCDA)
                    .then(function () { return cda_1.deserializeCDA(serializedCDA); })
                    .then(function (cda) {
                    return prepareTransfers('9'.repeat(81), [
                        {
                            address: cda.address,
                            value: 0
                        },
                    ])
                        .then(function (trytes) {
                        var bundleTrits = bundleTrytesToBundleTrits(trytes);
                        return persistence.put(['0', converter_1.tritsToTrytes(transaction_1.bundle(bundleTrits))].join(':'), bundleTrits);
                    })
                        .then(function () { return cda; });
                });
            });
        });
    }
    return { generateCDA: generateCDA };
}
exports.addressGeneration = addressGeneration;
function transactionIssuance(_a) {
    var _this = this;
    var seed = _a.seed, deposits = _a.deposits, persistence = _a.persistence, network = _a.network, timeSource = _a.timeSource, now = _a.now;
    var getBalance = network.getBalance, wereAddressesSpentFrom = network.wereAddressesSpentFrom;
    var prepareTransfers = core_1.createPrepareTransfers(undefined, now);
    var noChecksum = function (address) { return address.slice(0, -(cda_1.CDA_CHECKSUM_LENGTH / converter_1.TRYTE_WIDTH)); };
    var transactionIssuer = {
        sendToCDA: function (cdaTransfer) {
            if (!cdaTransfer) {
                throw new Error('Provide an object with conditions and value for the CDA transfer: { timeoutAt, [multiUse], [exeptectedAmount], [security=2], value }');
            }
            return (cdaTransfer.multiUse === true
                ? Promise.resolve()
                : persistence
                    .get([account_1.SENT_TO_ADDRESS_PREFIX, noChecksum(cdaTransfer.address)].join(':'))
                    .then(function () {
                    throw new Error("Aborted sending twice to the same address; " + noChecksum(cdaTransfer.address));
                })["catch"](function (error) {
                    if (!error.notFound) {
                        throw error;
                    }
                })).then(function () {
                return wereAddressesSpentFrom([noChecksum(cdaTransfer.address)]).then(function (_a) {
                    var spent = _a[0];
                    if (spent) {
                        throw new Error("Aborted sending to spent address; " + noChecksum(cdaTransfer.address));
                    }
                    return Promise["try"](function () {
                        return persistence
                            .ready()
                            .then(timeSource)
                            .then(function (currentTime) { return cda_1.verifyCDATransfer(currentTime, cdaTransfer); });
                    })
                        .then(function () { return accumulateInputs(cdaTransfer.value); })
                        .then(function (_a) {
                        var inputs = _a.inputs, totalBalance = _a.totalBalance;
                        inputs.forEach(function (input) { return _this.emit(Events.selectInput, { cdaTransfer: cdaTransfer, input: input }); });
                        var remainder = totalBalance - cdaTransfer.value;
                        return generateRemainderAddress(remainder).then(function (remainderAddress) {
                            return prepareTransfers(seed, [
                                {
                                    address: noChecksum(cdaTransfer.address),
                                    value: cdaTransfer.value
                                },
                            ], {
                                inputs: inputs.map(function (input) { return ({
                                    address: converter_1.tritsToTrytes(input.address),
                                    keyIndex: converter_1.tritsToValue(input.index),
                                    security: input.security,
                                    balance: input.balance
                                }); }),
                                remainderAddress: remainderAddress
                            })
                                .tap(function (trytes) { return _this.emit(Events.prepareTransfer, { cdaTransfer: cdaTransfer, trytes: trytes }); })
                                .tap(function (trytes) {
                                return persistence.batch(inputs.map(function (input) { return ({
                                    type: persistence_1.PersistenceBatchTypes.put,
                                    key: ['0', converter_1.tritsToTrytes(input.address)].join(':'),
                                    value: new Int8Array(1)
                                }); }).concat([
                                    {
                                        type: persistence_1.PersistenceBatchTypes.put,
                                        key: [
                                            '0',
                                            converter_1.tritsToTrytes(transaction_1.bundle(bundleTrytesToBundleTrits(trytes))),
                                        ].join(':'),
                                        value: bundleTrytesToBundleTrits(trytes)
                                    },
                                    {
                                        type: persistence_1.PersistenceBatchTypes.put,
                                        key: [account_1.SENT_TO_ADDRESS_PREFIX, noChecksum(cdaTransfer.address)].join(':'),
                                        value: converter_1.valueToTrits(cdaTransfer.timeoutAt)
                                    },
                                ]));
                            });
                        });
                    });
                });
            });
        }
    };
    var emitter = this; // tslint:disable-line
    function accumulateInputs(threshold, acc, buffer) {
        if (acc === void 0) { acc = { inputs: [], totalBalance: 0 }; }
        if (buffer === void 0) { buffer = []; }
        if (deposits.inboundLength() === 0) {
            buffer.forEach(deposits.write);
            acc.inputs.map(cda_1.serializeCDAInput).forEach(deposits.write);
            throw new Error('Insufficient balance');
        }
        return deposits.read().then(function (cda) {
            return timeSource()
                .then(function (currentTime) {
                var input = cda_1.deserializeCDAInput(cda);
                var address = converter_1.tritsToTrytes(input.address);
                return getBalance(address).then(function (balance) {
                    //
                    // Input selection Conditions
                    //
                    // The following strategy is blocking execution because it awaits arrival of balance on inputs.
                    // A strategy leading to eventual input selection should be discussed.
                    // Such us inputs are selected prior to inclusion of funding transactions,
                    // and order of funding and withdrawing is not important.
                    // This would allow for _transduction_ of transfers instead of reduction of inputs.
                    //
                    if (balance > 0 &&
                        ((input.expectedAmount && balance >= input.expectedAmount) ||
                            (input.multiUse && cda_1.isExpired(currentTime, input)) ||
                            !input.multiUse)) {
                        return wereAddressesSpentFrom([address]).then(function (_a) {
                            var spent = _a[0];
                            if (spent) {
                                return persistence.put(['0', address].join(':'), new Int8Array(1)).then(function () {
                                    return emitter.emit('error', new Error('Skipping spent input.'), {
                                        address: address,
                                        balance: balance
                                    });
                                });
                            }
                            acc.inputs.push(__assign({}, input, { balance: balance }));
                            acc.totalBalance += balance;
                        });
                    }
                    else if (input.timeoutAt !== 0 && cda_1.isExpired(currentTime, input)) {
                        return persistence.put(['0', address].join(':'), new Int8Array(1));
                    }
                    else {
                        buffer.push(cda); // restore later
                    }
                });
            })["catch"](function (error) {
                // TODO: add a "maxRetries" argument
                deposits.write(cda); // enables retries after network/db errors
                emitter.emit('error', error);
            })
                .then(function () { return (acc.totalBalance >= threshold ? acc : accumulateInputs(threshold, acc, buffer)); });
        });
    }
    function generateRemainderAddress(remainder) {
        if (remainder === 0) {
            return Promise.resolve(undefined);
        }
        return persistence.increment().then(function (index) {
            var security = 2;
            var remainderAddress = signing_1.address(signing_1.digests(signing_1.key(signing_1.subseed(seed, converter_1.tritsToValue(index)), security)));
            var addressTrytes = converter_1.tritsToTrytes(remainderAddress);
            return network.isAddressUsed(addressTrytes).then(function (_a) {
                var isUsed = _a.isUsed, isSpent = _a.isSpent, transactions = _a.transactions;
                if (isUsed) {
                    return persistence
                        .put(['0', addressGeneration].join(':'), isSpent
                        ? new Int8Array(1)
                        : cda_1.serializeCDAInput({
                            address: remainderAddress,
                            index: index,
                            security: security,
                            timeoutAt: 0
                        }))
                        .then(function () {
                        return emitter.emit('error', new Error('Dropped used address.'), {
                            address: addressTrytes,
                            isSpent: isSpent,
                            transactions: transactions
                        });
                    })
                        .then(function () { return generateRemainderAddress(remainder); });
                }
                return persistence
                    .put(['0', converter_1.tritsToTrytes(remainderAddress)].join(':'), cda_1.serializeCDAInput({
                    address: remainderAddress,
                    index: index,
                    security: security,
                    timeoutAt: 0,
                    multiUse: false,
                    expectedAmount: remainder
                }))
                    .then(function () { return converter_1.tritsToTrytes(remainderAddress); });
            });
        });
    }
    return transactionIssuer;
}
exports.transactionIssuance = transactionIssuance;
function transactionAttachment(params) {
    var _this = this;
    var bundles = params.bundles, persistence = params.persistence, network = params.network;
    var findTransactions = network.findTransactions, storeAndBroadcast = network.storeAndBroadcast, getTransactionsToApprove = network.getTransactionsToApprove, attachToTangle = network.attachToTangle, getTrytes = network.getTrytes, getInclusionStates = network.getInclusionStates, getConsistency = network.getConsistency;
    var reference;
    var running = false;
    var attachToTangleRoutine = function (attachParams) {
        if (!running) {
            return false;
        }
        var depth = attachParams.depth, minWeightMagnitude = attachParams.minWeightMagnitude, maxDepth = attachParams.maxDepth, delay = attachParams.delay;
        bundles.read().then(function (bundle) {
            return Promise.resolve({ addresses: [converter_1.tritsToTrytes(transaction_1.address(bundle.slice(-transaction_1.TRANSACTION_LENGTH)))] })
                .then(findTransactions)
                .then(getTrytes)
                .then(function (pastAttachments) {
                return pastAttachments.filter(function (trytes) {
                    return converter_1.tritsToTrytes(transaction_1.bundle(bundle)) ===
                        trytes.slice(transaction_1.BUNDLE_OFFSET / converter_1.TRYTE_WIDTH, transaction_1.BUNDLE_OFFSET / converter_1.TRYTE_WIDTH + transaction_1.BUNDLE_LENGTH / converter_1.TRYTE_WIDTH);
                });
            })
                .then(function (pastAttachments) {
                return pastAttachments.map(function (trytes) { return converter_1.tritsToTrytes(transaction_1.transactionHash(converter_1.trytesToTrits(trytes))); });
            })
                .then(function (pastAttachmentHashes) {
                return getInclusionStates(pastAttachmentHashes).tap(function (inclusionStates) {
                    if (inclusionStates.indexOf(true) > -1) {
                        return persistence.del(['0', converter_1.tritsToTrytes(transaction_1.bundle(bundle))].join(':'));
                    }
                    return Promise.all(pastAttachmentHashes.map(function (h) { return getConsistency([h]); })).tap(function (consistencyStates) {
                        return consistencyStates.indexOf(true) > -1
                            ? setTimeout(function () { return bundles.write(bundle); }, delay)
                            : getTransactionsToApprove(depth, reference ? reference.hash : undefined)
                                .tap(function (transactionsToApprove) {
                                return _this.emit(Events.getTransactionsToApprove, {
                                    trytes: bundleTritsToBundleTrytes(bundle),
                                    transactionsToApprove: transactionsToApprove
                                });
                            })
                                .then(function (_a) {
                                var trunkTransaction = _a.trunkTransaction, branchTransaction = _a.branchTransaction;
                                return attachToTangle(trunkTransaction, branchTransaction, minWeightMagnitude, bundleTritsToBundleTrytes(bundle));
                            })
                                .tap(function (transactions) {
                                return _this.emit(Events.attachToTangle, transactions.map(function (t) { return transaction_converter_1.asTransactionObject(t); }));
                            })
                                .then(function (attachedTrytes) { return storeAndBroadcast(attachedTrytes); })
                                .tap(function (attachedTrytes) {
                                return _this.emit(Events.broadcast, attachedTrytes.map(function (t) { return transaction_converter_1.asTransactionObject(t); }));
                            })
                                .then(function (attachedTrytes) { return attachedTrytes.map(function (t) { return transaction_converter_1.asTransactionObject(t); }); })
                                .tap(function (_a) {
                                var tail = _a[0];
                                if (!reference || !core_1.isAboveMaxDepth(reference.attachmentTimestamp, maxDepth)) {
                                    reference = tail;
                                }
                                else {
                                    return getConsistency([tail.hash]).then(function (consistent) {
                                        if (!consistent) {
                                            reference = tail;
                                        }
                                    });
                                }
                                setTimeout(function () { return bundles.write(bundle); }, delay);
                            });
                    });
                });
            })
                .tap(function () { return setTimeout(function () { return attachToTangleRoutine(attachParams); }, 1000); })["catch"](function (error) {
                bundles.write(bundle);
                _this.emit(Events.error, error);
            });
        });
    };
    return {
        startAttaching: function (startParams) {
            if (running) {
                return;
            }
            running = true;
            attachToTangleRoutine(startParams);
        },
        stopAttaching: function () {
            if (!running) {
                return;
            }
            running = false;
        }
    };
}
exports.transactionAttachment = transactionAttachment;
function createAccountPreset(test) {
    if (test === void 0) { test = {}; }
    return {
        persistencePath: './',
        persistenceAdapter: persistence_adapter_level_1.createPersistenceAdapter,
        provider: 'http://localhost:14265',
        network: networkAdapter,
        security: 2,
        addressGeneration: addressGeneration,
        transactionIssuance: transactionIssuance,
        transactionAttachment: transactionAttachment,
        timeSource: function () { return Promise.resolve(Math.floor(Date.now() / 1000)); },
        depth: 3,
        minWeightMagnitude: 9,
        delay: 1000 * 30,
        pollingDelay: 1000 * 30,
        maxDepth: 6,
        test: test
    };
}
exports.createAccountPreset = createAccountPreset;
exports.preset = createAccountPreset();
exports.testPreset = createAccountPreset({
    now: function () { return 1; }
});
function bundleTritsToBundleTrytes(trits) {
    var out = [];
    for (var offset = 0; offset < trits.length; offset += transaction_1.TRANSACTION_LENGTH) {
        out.push(converter_1.tritsToTrytes(trits.slice(offset, offset + transaction_1.TRANSACTION_LENGTH)));
    }
    return out;
}
function bundleTrytesToBundleTrits(trytes) {
    var out = new Int8Array(trytes.length * transaction_1.TRANSACTION_LENGTH);
    for (var i = 0; i < trytes.length; i++) {
        out.set(converter_1.trytesToTrits(trytes[i]), i * transaction_1.TRANSACTION_LENGTH);
    }
    return out;
}
//# sourceMappingURL=preset.js.map