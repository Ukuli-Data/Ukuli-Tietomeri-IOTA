"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var async_buffer_1 = require("@iota/async-buffer");
var cda_1 = require("@iota/cda");
var converter_1 = require("@iota/converter");
var persistence_1 = require("@iota/persistence");
var transaction_1 = require("@iota/transaction");
var transaction_converter_1 = require("@iota/transaction-converter");
var events_1 = require("events");
var preset_1 = require("./preset");
exports.SENT_TO_ADDRESS_PREFIX = 'sent_to';
function createAccountWithPreset(preset) {
    return function (_a) {
        var seed = _a.seed, _b = _a.persistencePath, persistencePath = _b === void 0 ? preset.persistencePath : _b, _c = _a.persistenceAdapter, persistenceAdapter = _c === void 0 ? preset.persistenceAdapter : _c, _d = _a.provider, provider = _d === void 0 ? preset.provider : _d, _e = _a.network, network = _e === void 0 ? preset.network({ provider: provider }) : _e, _f = _a.timeSource, timeSource = _f === void 0 ? preset.timeSource : _f, _g = _a.depth, depth = _g === void 0 ? preset.depth : _g, _h = _a.minWeightMagnitude, minWeightMagnitude = _h === void 0 ? preset.minWeightMagnitude : _h, _j = _a.delay, delay = _j === void 0 ? preset.delay : _j, _k = _a.pollingDelay, pollingDelay = _k === void 0 ? preset.pollingDelay : _k, _l = _a.maxDepth, maxDepth = _l === void 0 ? preset.maxDepth : _l, _m = _a.emitTransferEvents, emitTransferEvents = _m === void 0 ? true : _m;
        if (typeof seed === 'string') {
            seed = converter_1.trytesToTrits(seed);
        }
        var addresses = [];
        var bundles = async_buffer_1.asyncBuffer();
        var deposits = async_buffer_1.asyncBuffer();
        var depositsList = [];
        var withdrawalsList = [];
        var transferEventsTimeout;
        var running = true;
        var persistence = persistence_1.createPersistence(persistenceAdapter({
            persistenceID: persistence_1.generatePersistenceID(seed),
            persistencePath: persistencePath
        }));
        function accountMixin() {
            var _this = this;
            return Object.assign(this, preset.addressGeneration.call(this, {
                seed: seed,
                persistence: persistence,
                timeSource: timeSource,
                security: preset.security,
                network: network,
                now: preset.test.now
            }), preset.transactionIssuance.call(this, {
                seed: seed,
                deposits: deposits,
                persistence: persistence,
                network: network,
                timeSource: timeSource,
                security: preset.security,
                now: preset.test.now
            }), preset.transactionAttachment.call(this, {
                bundles: bundles,
                persistence: persistence,
                network: network
            }), {
                stop: function () {
                    if (running) {
                        running = false;
                        _this.stopAttaching();
                        clearTimeout(transferEventsTimeout);
                        return persistence.close();
                    }
                },
                start: function () {
                    if (running) {
                        return;
                    }
                    running = true;
                    return persistence.open().then(function () {
                        if (emitTransferEvents) {
                            transferEventsTimeout = setTimeout(transferEvents, pollingDelay);
                        }
                        _this.startAttaching();
                    });
                },
                getTotalBalance: function () {
                    return persistence
                        .ready()
                        .then(function () { return network.getBalances(addresses); })
                        .then(function (_a) {
                        var balances = _a.balances;
                        return balances.reduce(function (acc, b) { return (acc += b); }, 0);
                    });
                },
                getAvailableBalance: function () {
                    return persistence
                        .ready()
                        .then(function () { return timeSource(); })
                        .then(function (currentTime) {
                        var depositsListCopy = depositsList.slice();
                        return network
                            .getBalances(depositsListCopy.map(function (_a) {
                            var address = _a.address;
                            return converter_1.tritsToTrytes(address);
                        }))
                            .then(function (_a) {
                            var balances = _a.balances;
                            var acc = 0;
                            depositsListCopy.forEach(function (input, i) {
                                if (balances[i] > 0) {
                                    if (input.expectedAmount && balances[i] >= input.expectedAmount) {
                                        acc += balances[i];
                                    }
                                    else if (input.multiUse && cda_1.isExpired(currentTime, input)) {
                                        acc += balances[i];
                                    }
                                    else if (!input.multiUse) {
                                        acc += balances[i];
                                    }
                                }
                            });
                            return acc;
                        });
                    });
                },
                getDeposits: function () {
                    return persistence
                        .ready()
                        .then(function () {
                        return depositsList.slice().map(function (deposit) { return (__assign({}, deposit, { address: converter_1.tritsToTrytes(deposit.address), index: converter_1.tritsToValue(deposit.index) })); });
                    })
                        .then(function (depositsListCopy) {
                        return network
                            .getBalances(depositsListCopy.map(function (deposit) { return deposit.address; }))
                            .then(function (_a) {
                            var balances = _a.balances;
                            return depositsListCopy.map(function (deposit, i) { return (__assign({}, deposit, { balance: balances[i] })); });
                        });
                    });
                },
                getWithdrawals: function () {
                    return persistence.ready().then(function () { return withdrawalsList.slice(); });
                },
                exportState: function () {
                    return persistence
                        .ready()
                        .then(function () { return persistence.get('key_index'); })
                        .then(function (lastKeyIndex) { return ({
                        lastKeyIndex: lastKeyIndex,
                        deposits: depositsList.slice().map(function (deposit) { return (__assign({}, deposit, { address: converter_1.tritsToTrytes(deposit.address), index: converter_1.tritsToValue(deposit.index) })); }),
                        withdrawals: withdrawalsList.slice()
                    }); });
                },
                importState: function (state) {
                    return persistence.ready().then(function () {
                        return persistence.batch([
                            {
                                type: persistence_1.PersistenceBatchTypes.put,
                                key: 'key_index',
                                value: converter_1.valueToTrits(state.lastKeyIndex)
                            }
                        ].concat(state.deposits.map(function (deposit) { return ({
                            type: 'put',
                            key: ['0', ':', deposit.address].join(''),
                            value: cda_1.serializeCDAInput(__assign({}, deposit, { address: converter_1.trytesToTrits(deposit.address), index: converter_1.trytesToTrits(deposit.index) }))
                        }); }), state.withdrawals.map(function (withdrawal) {
                            var trits = new Int8Array(withdrawal.length * transaction_1.TRANSACTION_LENGTH);
                            for (var i = 0; i < withdrawal.length; i++) {
                                trits.set(converter_1.trytesToTrits(withdrawal[i]), i * transaction_1.TRANSACTION_LENGTH);
                            }
                            return {
                                type: persistence_1.PersistenceBatchTypes.put,
                                key: ['0', ':', converter_1.tritsToTrytes(transaction_1.bundle(trits))].join(''),
                                value: trits
                            };
                        })));
                    });
                }
            }, events_1.EventEmitter.prototype);
        }
        var target = {};
        var account = accountMixin.call(target);
        persistence.on('data', function (_a) {
            var key = _a.key, value = _a.value;
            var trits = Int8Array.from(value);
            var _b = key.toString().split(':'), prefix = _b[0], id = _b[1];
            if (prefix === '0') {
                if (transaction_1.isMultipleOfTransactionLength(trits.length)) {
                    bundles.write(trits);
                    var bundle = [];
                    for (var offset = 0; offset < trits.length; offset += transaction_1.TRANSACTION_LENGTH) {
                        bundle.push(transaction_converter_1.asTransactionObject(converter_1.tritsToTrytes(trits.slice(offset, offset + transaction_1.TRANSACTION_LENGTH))));
                    }
                    withdrawalsList.push(bundle);
                }
                if (trits.length === cda_1.CDA_LENGTH) {
                    deposits.write(trits);
                    var cda = cda_1.deserializeCDAInput(trits);
                    depositsList.push(cda);
                    addresses.push(converter_1.tritsToTrytes(cda.address));
                }
                if (trits.length === 1) {
                    // used address, don't list it as deposit or pass it to input selection
                    addresses.push(id);
                }
            }
            else if (prefix === exports.SENT_TO_ADDRESS_PREFIX) {
                timeSource().then(function (now) {
                    if (converter_1.tritsToValue(trits) <= now) {
                        persistence.del([prefix, id].join(':'))["catch"](function (error) { return account.emit('error', error); });
                    }
                });
            }
        });
        var emittedIncludedDeposits = {};
        var emittedPendingDeposits = {};
        var emittedIncludedWithdrawals = {};
        var emittedPendingWithdrawals = {};
        var transferEvents = function () {
            return persistence
                .ready()
                .then(function () { return network.getBundlesFromAddresses(addresses, true); })
                .then(function (bundlesFromAddresses) {
                bundlesFromAddresses
                    .filter(function (bundle) {
                    return (emittedIncludedDeposits[bundle[0].hash] !== true &&
                        bundle[0].persistence === true) ||
                        (emittedPendingDeposits[bundle[0].hash] !== true &&
                            bundle[0].persistence === false);
                })
                    .filter(function (bundle) {
                    return bundle.findIndex(function (tx) { return addresses.indexOf(tx.address) > -1 && tx.value > 0; }) > -1;
                })
                    .forEach(function (bundle) {
                    return bundle
                        .filter(function (tx) { return addresses.indexOf(tx.address) > -1 && tx.value > 0; })
                        .forEach(function (tx) {
                        account.emit(bundle[0].persistence ? 'includedDeposit' : 'pendingDeposit', {
                            address: tx.address,
                            bundle: bundle
                        });
                        if (bundle[0].persistence) {
                            emittedIncludedDeposits[bundle[0].hash] = true;
                        }
                        else {
                            emittedPendingDeposits[bundle[0].hash] = true;
                        }
                    });
                });
                bundlesFromAddresses
                    .filter(function (bundle) {
                    return (emittedIncludedWithdrawals[bundle[0].hash] !== true &&
                        bundle[0].persistence === true) ||
                        (emittedPendingWithdrawals[bundle[0].hash] !== true &&
                            bundle[0].persistence === false);
                })
                    .filter(function (bundle) {
                    return bundle.findIndex(function (tx) { return addresses.indexOf(tx.address) > -1 && tx.value < 0; }) > -1;
                })
                    .forEach(function (bundle) {
                    return bundle
                        .filter(function (tx) { return addresses.indexOf(tx.address) > -1 && tx.value < 0; })
                        .forEach(function (tx) {
                        account.emit(bundle[0].persistence ? 'includedWithdrawal' : 'pendingWithdrawal', {
                            address: tx.address,
                            bundle: bundle
                        });
                        if (bundle[0].persistence) {
                            emittedIncludedWithdrawals[bundle[0].hash] = true;
                        }
                        else {
                            emittedPendingWithdrawals[bundle[0].hash] = true;
                        }
                    });
                });
            })["catch"](function (error) { return account.emit('error', error); })
                .then(function () {
                transferEventsTimeout = setTimeout(transferEvents, pollingDelay);
            });
        };
        if (running) {
            persistence
                .ready()
                .then(function () {
                account.startAttaching({
                    depth: depth,
                    minWeightMagnitude: minWeightMagnitude,
                    delay: delay,
                    maxDepth: maxDepth
                });
                if (emitTransferEvents) {
                    transferEvents();
                }
            })["catch"](function (error) { return account.emit('error', error); });
        }
        account.on('error', function () { }); // tslint:disable-line
        return account;
    };
}
exports.createAccountWithPreset = createAccountWithPreset;
exports.createAccount = createAccountWithPreset(preset_1.preset);
//# sourceMappingURL=account.js.map