"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var core_1 = require("@iota/core");
var BluebirdPromise = require("bluebird");
var nock = require("nock");
var riteway_1 = require("riteway");
var types_1 = require("../../types");
var account_1 = require("../src/account");
var preset_1 = require("../src/preset");
var trytes_1 = require("./trytes");
var persistencePath = './test/temp';
var currentTime = Math.floor(Date.now() / 1000);
var futureTime = 6833278800;
var pastTime = currentTime - 7 * 24 * 60 * 60 * 1000;
var noChecksum = function (address) { return address.slice(0, 81); };
var headers = {
    reqheaders: {
        'Content-Type': 'application/json',
        'X-IOTA-API-Version': '1'
    }
};
var assertAddressTransactions = function (address, hashes) {
    return nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.FIND_TRANSACTIONS,
        addresses: [noChecksum(address)]
    })
        .times(1)
        .reply(200, {
        hashes: hashes
    });
};
var assertRemoteSpentState = function (address, state) {
    return nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.WERE_ADDRESSES_SPENT_FROM,
        addresses: [noChecksum(address)]
    })
        .times(1)
        .reply(200, {
        states: [state]
    });
};
var assertBalance = function (address, balance) {
    return nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.GET_BALANCES,
        addresses: [noChecksum(address)]
    })
        .times(1)
        .reply(200, {
        balances: [balance],
        milestone: 'M'.repeat(81),
        milestoneIndex: 1
    });
};
var assertTransfer = function (transfer, trytes) {
    var hash = 'ZZKVOZRYHZVYORKHDLWRNIWKWLZMVBNFSPQC99PYHVJFRYRHXVUTHPQOVPJBRNFLYWDNKBBUJOTDQVTDE';
    var transactionsToApprove = {
        trunkTransaction: '9'.repeat(81),
        branchTransaction: '9'.repeat(81)
    };
    assertAddressTransactions(transfer.address, [hash]);
    nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.GET_TRYTES,
        hashes: [hash]
    })
        .times(1)
        .reply(200, {
        trytes: [trytes[0]]
    });
    nock('http://localhost:14265', headers)
        .persist()
        .post('/', { command: types_1.IRICommand.GET_NODE_INFO })
        .reply(200, {
        appName: 'IRI',
        appVersion: '',
        duration: 100,
        jreAvailableProcessors: 4,
        jreFreeMemory: 13020403,
        jreMaxMemory: 1241331231,
        jreTotalMemory: 4245234332,
        latestMilestone: 'M'.repeat(81),
        latestMilestoneIndex: 1,
        latestSolidSubtangleMilestone: 'M'.repeat(81),
        latestSolidSubtangleMilestoneIndex: 1,
        neighbors: 5,
        packetsQueueSize: 23,
        time: 213213214,
        tips: 123,
        transactionsToRequest: 10
    });
    nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.GET_INCLUSION_STATES,
        transactions: [hash],
        tips: ['M'.repeat(81)]
    })
        .times(1)
        .reply(200, {
        states: [false]
    });
    nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.CHECK_CONSISTENCY,
        tails: [hash]
    })
        .times(1)
        .reply(200, {
        states: [false]
    });
    nock('http://localhost:14265', headers)
        .post('/', {
        command: types_1.IRICommand.GET_TRANSACTIONS_TO_APPROVE,
        depth: 3
    })
        .times(1)
        .reply(200, __assign({}, transactionsToApprove));
    nock('http://localhost:14265', headers)
        .post('/', __assign({ command: types_1.IRICommand.ATTACH_TO_TANGLE, trytes: trytes_1.accountASends10iToB.slice() }, transactionsToApprove, { minWeightMagnitude: 9 }))
        .times(1)
        .reply(200, {
        trytes: trytes_1.accountASends10iToB.slice()
    });
};
riteway_1.describe('account.generateCDA()', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var seed, accountParams, account, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return __generator(this, function (_l) {
        switch (_l.label) {
            case 0:
                seed = 'RQMMPLNFUUCULIIHEYKYBUXUFEDPKTXDQQQRUOBUVIVWIOAXDPNHLAJDSPCXKJNPTPJYBBCJKPVMONYDK';
                accountParams = {
                    seed: seed,
                    persistencePath: persistencePath,
                    emitTransferEvents: false
                };
                account = account_1.createAccount(accountParams);
                _a = assert;
                _b = {
                    given: 'timeoutAt, multiUse & expectedAmount conditions',
                    should: 'throw error'
                };
                return [4 /*yield*/, riteway_1.Try(account.generateCDA, {
                        timeoutAt: futureTime,
                        multiUse: true,
                        expectedAmount: 9
                    })];
            case 1:
                _a.apply(void 0, [(_b.actual = (_l.sent()).toString(),
                        _b.expected = 'TypeError: Only one of the following fields can be set: multiUse, expectedAmount',
                        _b)]);
                _c = assert;
                _d = {
                    given: 'timeoutAt & multiUse conditions',
                    should: 'generate 1st CDA'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        var address = core_1.generateAddress(seed, 1, 2, false);
                        assertRemoteSpentState(address, false);
                        assertAddressTransactions(address, []);
                        return account.generateCDA({
                            timeoutAt: futureTime,
                            multiUse: false
                        });
                    })];
            case 2:
                _c.apply(void 0, [(_d.actual = _l.sent(),
                        _d.expected = {
                            address: 'FSPPZHWG9FCUBVTNGMPIUVLMXRUAIWFEXRF9IYHPIYJRIORYOOEDBJN9WBFODDFLAKUOKYFZGDLHZNCXXPZZJZPHFT',
                            timeoutAt: futureTime,
                            multiUse: false,
                            expectedAmount: 0
                        },
                        _d)]);
                _e = assert;
                _f = {
                    given: 'timeoutAt & expectedAmount conditions',
                    should: 'generate 2nd CDA'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        var address = core_1.generateAddress(seed, 2, 2, false);
                        assertRemoteSpentState(address, false);
                        assertAddressTransactions(address, []);
                        return account.generateCDA({
                            timeoutAt: futureTime,
                            expectedAmount: 9
                        });
                    })];
            case 3:
                _e.apply(void 0, [(_f.actual = _l.sent(),
                        _f.expected = {
                            address: 'KRXPZHNMGVJKBIQXV9ALWFOPGIGNVTJFNVKHSYZLI9AABBHKSPBTKKPRVI9ID9QXXKZGTXSSSBMUQFVLWJYJMXKPRS',
                            timeoutAt: futureTime,
                            multiUse: false,
                            expectedAmount: 9
                        },
                        _f)]);
                _g = assert;
                _h = {
                    given: 'timeoutAt & expectedAmount conditions',
                    should: 'generate 5th CDA if 3rd & 4th are spent'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        var c = core_1.generateAddress(seed, 3, 2, false);
                        var d = core_1.generateAddress(seed, 4, 2, false);
                        var e = core_1.generateAddress(seed, 5, 2, false);
                        assertRemoteSpentState(c, true);
                        assertAddressTransactions(c, []);
                        assertRemoteSpentState(d, false);
                        assertAddressTransactions(d, ['9'.repeat(81)]);
                        assertRemoteSpentState(e, false);
                        assertAddressTransactions(e, []);
                        return account.generateCDA({
                            timeoutAt: futureTime,
                            expectedAmount: 9
                        });
                    })];
            case 4:
                _g.apply(void 0, [(_h.actual = _l.sent(),
                        _h.expected = {
                            address: 'AJYHQPBOFNUY9BSANYJUNAWWCIZVFVLLTWDUCN9GOMH9GAYUS9QTZITDQRIQUPGMKZZMSJMQVA999V9VX9OUCRAPFV',
                            timeoutAt: futureTime,
                            multiUse: false,
                            expectedAmount: 9
                        },
                        _h)]);
                _j = assert;
                _k = {
                    given: 'past time as timeoutAt',
                    should: 'throw "Expired timeout" Error'
                };
                return [4 /*yield*/, riteway_1.Try(account.generateCDA, {
                        timeoutAt: pastTime,
                        expectedAmount: 9
                    })];
            case 5:
                _j.apply(void 0, [(_k.actual = (_l.sent()).toString(),
                        _k.expected = 'Error: Expired timeout.',
                        _k)]);
                return [2 /*return*/];
        }
    });
}); });
riteway_1.describe('account.generateCDA/account.sendToCDA', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var seed0, seedA, seedB, account0, accountA, accountB, a1, a2, a3, a4, b1, B1, b2, B2, b3, B3, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    var _this = this;
    return __generator(this, function (_u) {
        switch (_u.label) {
            case 0:
                seed0 = '9'.repeat(81);
                seedA = 'RQFLPKU9BIEGPPEIXEHH9RFDUMSYXMPZOVBKBITSPEFMSOIBYHMFVHRNRF9YNZYQRNBYCS9OULYHBFPHZ';
                seedB = 'ZKKZDWNKIWYQHCNTHKAEARYIWUYUBDWVXWWT9FQDOKPNZURMGRFJABUYTLYEQKDVJCNQYKLTVIVSTY9LI';
                account0 = account_1.createAccount({
                    seed: converter_1.trytesToTrits('9'.repeat(81)),
                    persistencePath: persistencePath,
                    emitTransferEvents: false,
                    timeSource: function () { return BluebirdPromise.resolve(Math.floor(Date.now() / 1000)); }
                });
                accountA = account_1.createAccountWithPreset(__assign({}, preset_1.preset, { test: {
                        now: function () { return futureTime; }
                    } }))({
                    seed: converter_1.trytesToTrits(seedA),
                    emitTransferEvents: false,
                    persistencePath: persistencePath
                });
                accountB = account_1.createAccountWithPreset(__assign({}, preset_1.preset, { now: function () { return futureTime; } }))({
                    seed: converter_1.trytesToTrits(seedB),
                    emitTransferEvents: false,
                    persistencePath: persistencePath
                });
                a1 = core_1.generateAddress(seedA, 1, 2, false);
                assertRemoteSpentState(a1, false);
                assertAddressTransactions(a1, []);
                return [4 /*yield*/, accountA.generateCDA({
                        timeoutAt: Math.floor(Date.now() / 1000) + 5,
                        multiUse: true
                    })];
            case 1:
                _u.sent();
                a2 = core_1.generateAddress(seedA, 2, 2, false);
                assertRemoteSpentState(a2, false);
                assertAddressTransactions(a2, []);
                return [4 /*yield*/, accountA.generateCDA({
                        timeoutAt: futureTime,
                        expectedAmount: 3
                    })];
            case 2:
                _u.sent();
                a3 = core_1.generateAddress(seedA, 3, 2, false);
                a4 = core_1.generateAddress(seedA, 4, 2, false);
                b1 = core_1.generateAddress(seedB, 1, 2, false);
                assertRemoteSpentState(b1, false);
                assertAddressTransactions(b1, []);
                return [4 /*yield*/, accountB.generateCDA({
                        timeoutAt: futureTime,
                        multiUse: true
                    })];
            case 3:
                B1 = _u.sent();
                b2 = core_1.generateAddress(seedB, 2, 2, false);
                assertRemoteSpentState(b2, false);
                assertAddressTransactions(b2, []);
                return [4 /*yield*/, accountB.generateCDA({
                        timeoutAt: futureTime,
                        expectedAmount: 10
                    })];
            case 4:
                B2 = _u.sent();
                b3 = core_1.generateAddress(seedB, 3, 2, false);
                assertRemoteSpentState(b3, false);
                assertAddressTransactions(b3, []);
                return [4 /*yield*/, accountB.generateCDA({
                        timeoutAt: futureTime,
                        expectedAmount: 1,
                        multiUse: false
                    })];
            case 5:
                B3 = _u.sent();
                _a = assert;
                _b = {
                    given: 'that account has 0 persisted CDAs, sendToCDA',
                    should: 'throw "Insufficient balance" error'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        assertRemoteSpentState(B1.address, false);
                        assertAddressTransactions(B1.address, []);
                        return account0.sendToCDA(__assign({}, B1, { value: 1 }));
                    })];
            case 6:
                _a.apply(void 0, [(_b.actual = (_u.sent()).toString(),
                        _b.expected = 'Error: Insufficient balance',
                        _b)]);
                _c = assert;
                _d = {
                    given: 'an expired CDA, sendToCDA',
                    should: 'throw "Expired timeout" error'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        var address = 'A'.repeat(90);
                        assertRemoteSpentState(address, false);
                        return account0.sendToCDA({ address: address, timeoutAt: pastTime, value: 1 });
                    })];
            case 7:
                _c.apply(void 0, [(_d.actual = (_u.sent()).toString(),
                        _d.expected = 'Error: Expired timeout.',
                        _d)]);
                _e = assert;
                _f = {
                    given: 'that account has 1 persisted, unfunded CDA, sendToCDA',
                    should: 'throw "Insufficient balance" error'
                };
                return [4 /*yield*/, riteway_1.Try(function () { return __awaiter(_this, void 0, void 0, function () {
                        var address, value;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    address = core_1.generateAddress(seed0, 1, 2, false);
                                    assertRemoteSpentState(address, false);
                                    assertAddressTransactions(address, []);
                                    value = 1;
                                    return [4 /*yield*/, account0.generateCDA({
                                            timeoutAt: futureTime,
                                            expectedAmount: value
                                        })];
                                case 1:
                                    _a.sent();
                                    assertBalance(address, value - 1);
                                    assertRemoteSpentState(B1.address, false);
                                    return [2 /*return*/, account0.sendToCDA(__assign({}, B1, { value: value }))];
                            }
                        });
                    }); })];
            case 8:
                _e.apply(void 0, [(_f.actual = (_u.sent()).toString(),
                        _f.expected = 'Error: Insufficient balance',
                        _f)]);
                _g = assert;
                _h = {
                    given: 'that account has 1 persisted, funded but spent CDA, sendToCDA',
                    should: 'throw "Insufficient balance" error & drop the spent input'
                };
                return [4 /*yield*/, riteway_1.Try(function () { return __awaiter(_this, void 0, void 0, function () {
                        var rejected, emitted, address, value, error_1, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    rejected = '';
                                    emitted = new Promise(function (resolve) {
                                        return account0.on('error', function (error, input) {
                                            if (input !== undefined && input.address && input.balance) {
                                                resolve({
                                                    error: error.toString(),
                                                    address: input.address,
                                                    balance: input.balance
                                                });
                                            }
                                        });
                                    });
                                    address = core_1.generateAddress(seed0, 1, 2, false);
                                    value = 1;
                                    assertBalance(address, value);
                                    assertRemoteSpentState(address, true);
                                    assertRemoteSpentState(B1.address, false);
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, account0.sendToCDA(__assign({}, B1, { value: value }))];
                                case 2:
                                    _b.sent();
                                    return [3 /*break*/, 4];
                                case 3:
                                    error_1 = _b.sent();
                                    rejected = error_1.toString();
                                    return [3 /*break*/, 4];
                                case 4:
                                    _a = {
                                        rejected: rejected
                                    };
                                    return [4 /*yield*/, emitted];
                                case 5: return [2 /*return*/, (_a.emitted = _b.sent(),
                                        _a)];
                            }
                        });
                    }); })];
            case 9:
                _g.apply(void 0, [(_h.actual = _u.sent(),
                        _h.expected = {
                            rejected: 'Error: Insufficient balance',
                            emitted: {
                                error: 'Error: Skipping spent input.',
                                address: core_1.generateAddress(seed0, 1, 2, false),
                                balance: 1
                            }
                        },
                        _h)]);
                _j = assert;
                _k = {
                    given: 'that account A has 12i balance in snapshot (A1: 9i, A2: 3i)',
                    should: 'send 10i to B'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        assertBalance(a1, 9);
                        assertBalance(a2, 3);
                        assertRemoteSpentState(a1, false);
                        assertRemoteSpentState(a2, false);
                        assertRemoteSpentState(a3, false);
                        assertAddressTransactions(a3, []);
                        assertRemoteSpentState(B2.address, false);
                        assertTransfer(B2, trytes_1.accountASends10iToB);
                        return accountA.sendToCDA(__assign({}, B2, { value: B2.expectedAmount }));
                    })];
            case 10:
                _j.apply(void 0, [(_k.actual = _u.sent(),
                        _k.expected = trytes_1.accountASends10iToB,
                        _k)]);
                _l = assert;
                _m = {
                    given: 'that previous transfer of 10i to B is included, account A',
                    should: 'be able to spend 1i from remainder address A3'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        assertBalance(a3, 2);
                        assertRemoteSpentState(a3, false);
                        assertRemoteSpentState(a4, false);
                        assertAddressTransactions(a4, []);
                        assertRemoteSpentState(B1.address, false);
                        return accountA.sendToCDA(__assign({}, B1, { value: 1 }));
                    })];
            case 11:
                _l.apply(void 0, [(_m.actual = _u.sent(),
                        _m.expected = trytes_1.accountASpendsFromRemainder,
                        _m)]);
                _o = assert;
                _p = {
                    given: 'that account A has used all inputs in previous transfers (except one with insufficient balance of 1i), sendToCDA',
                    should: 'throw "insufficient balance" error'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        assertBalance(a4, 1);
                        assertRemoteSpentState(a4, false);
                        assertRemoteSpentState(B1.address, false);
                        return accountA.sendToCDA(__assign({}, B1, { value: 2 }));
                    })];
            case 12:
                _o.apply(void 0, [(_p.actual = (_u.sent()).toString(),
                        _p.expected = 'Error: Insufficient balance',
                        _p)]);
                _q = assert;
                _r = {
                    given: 'that CDA is spent from',
                    should: 'throw error'
                };
                return [4 /*yield*/, riteway_1.Try(function () {
                        assertRemoteSpentState(B1.address, true);
                        return accountA.sendToCDA(__assign({}, B1, { value: 2 }));
                    })];
            case 13:
                _q.apply(void 0, [(_r.actual = (_u.sent()).toString(),
                        _r.expected = "Error: Aborted sending to spent address; " + noChecksum(B1.address),
                        _r)]);
                _s = assert;
                _t = {
                    given: 'a CDA with multiUse=false',
                    should: 'allow only one transfer'
                };
                return [4 /*yield*/, riteway_1.Try(function () { return __awaiter(_this, void 0, void 0, function () {
                        var value, transfer;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    value = 1;
                                    transfer = __assign({}, B3, { value: value });
                                    assertBalance(a4, value);
                                    assertRemoteSpentState(a4, false);
                                    assertRemoteSpentState(B3.address, false);
                                    return [4 /*yield*/, accountA.sendToCDA(transfer)];
                                case 1:
                                    _a.sent();
                                    assertBalance(a4, value);
                                    assertRemoteSpentState(B3.address, false);
                                    return [2 /*return*/, accountA.sendToCDA(transfer)];
                            }
                        });
                    }); })];
            case 14:
                _s.apply(void 0, [(_t.actual = (_u.sent()).toString(),
                        _t.expected = "Error: Aborted sending twice to the same address; " + noChecksum(B3.address),
                        _t)]);
                return [2 /*return*/];
        }
    });
}); });
//# sourceMappingURL=account.test.js.map